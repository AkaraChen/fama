use std::env;
use std::fs;
use std::path::PathBuf;

fn main() {
	let manifest_dir = PathBuf::from(env::var("CARGO_MANIFEST_DIR").unwrap());
	let out_dir = PathBuf::from(env::var("OUT_DIR").unwrap());
	let bin_dir = manifest_dir.join("bin");

	println!("cargo:rerun-if-changed={}", bin_dir.display());

	// Platform configurations matching GitHub Actions artifact names
	// Format: (arch, os, env, binary_name)
	let platforms = vec![
		// Linux
		("x86_64", "linux", None, "dart_style-linux-x86_64"),
		("aarch64", "linux", None, "dart_style-linux-aarch64"),
		// macOS
		("x86_64", "macos", None, "dart_style-macos-x86_64"),
		("aarch64", "macos", None, "dart_style-macos-aarch64"),
		// Windows MSVC
		(
			"x86_64",
			"windows",
			Some("msvc"),
			"dart_style-windows-x86_64-msvc.exe",
		),
		(
			"x86",
			"windows",
			Some("msvc"),
			"dart_style-windows-i686-msvc.exe",
		),
		(
			"aarch64",
			"windows",
			Some("msvc"),
			"dart_style-windows-aarch64-msvc.exe",
		),
		// Windows GNU
		(
			"x86_64",
			"windows",
			Some("gnu"),
			"dart_style-windows-x86_64-gnu.exe",
		),
	];

	// Generate the binary data file
	let binary_data_rs = out_dir.join("binary_data.rs");
	let mut generated_code = String::new();

	generated_code.push_str("// Auto-generated by build.rs\n");
	generated_code.push_str(
		"// This file contains the embedded binary data for dart_style\n\n",
	);

	for (arch, os, env_opt, binary_name) in &platforms {
		let binary_path = bin_dir.join(binary_name);

		if binary_path.exists() {
			let size = fs::metadata(&binary_path).map(|m| m.len()).unwrap_or(0);
			if size > 0 {
				println!(
					"cargo:warning=Including binary for {}-{}: {} ({} bytes)",
					arch, os, binary_name, size
				);

				// Generate const name based on arch, os, and env
				let const_name = if let Some(env) = env_opt {
					format!(
						"BINARY_{}_{}_{}",
						arch.to_uppercase().replace("-", "_"),
						os.to_uppercase(),
						env.to_uppercase()
					)
				} else {
					format!(
						"BINARY_{}_{}",
						arch.to_uppercase().replace("-", "_"),
						os.to_uppercase()
					)
				};

				// Generate cfg attribute based on env
				let cfg_str = if let Some(env) = env_opt {
					format!(
						"#[cfg(all(target_arch = \"{}\", target_os = \"{}\", target_env = \"{}\"))]\n",
						arch, os, env
					)
				} else {
					format!(
						"#[cfg(all(target_arch = \"{}\", target_os = \"{}\"))]\n",
						arch, os
					)
				};

				// Convert path to forward slashes for include_bytes!
				let path_str = binary_path.to_string_lossy().replace('\\', "/");

				generated_code.push_str(&cfg_str);
				generated_code.push_str(&format!(
					"pub static {}: &[u8] = include_bytes!(\"{}\");\n\n",
					const_name, path_str
				));
			} else {
				println!(
					"cargo:warning=Binary file is empty for {}-{}: {}",
					arch,
					os,
					binary_path.display()
				);
				generate_placeholder(&mut generated_code, arch, os, *env_opt);
			}
		} else {
			println!(
				"cargo:warning=Binary not found for {}-{}: {}",
				arch,
				os,
				binary_path.display()
			);
			generate_placeholder(&mut generated_code, arch, os, *env_opt);
		}
	}

	fs::write(&binary_data_rs, generated_code)
		.expect("Failed to write binary_data.rs");

	println!(
		"cargo:warning=Generated binary data at {}",
		binary_data_rs.display()
	);
}

fn generate_placeholder(
	code: &mut String,
	arch: &str,
	os: &str,
	env_opt: Option<&str>,
) {
	let const_name = if let Some(env) = env_opt {
		format!(
			"BINARY_{}_{}_{}",
			arch.to_uppercase().replace("-", "_"),
			os.to_uppercase(),
			env.to_uppercase()
		)
	} else {
		format!(
			"BINARY_{}_{}",
			arch.to_uppercase().replace("-", "_"),
			os.to_uppercase()
		)
	};

	let cfg_str = if let Some(env) = env_opt {
		format!(
			"#[cfg(all(target_arch = \"{}\", target_os = \"{}\", target_env = \"{}\"))]\n",
			arch, os, env
		)
	} else {
		format!(
			"#[cfg(all(target_arch = \"{}\", target_os = \"{}\"))]\n",
			arch, os
		)
	};

	code.push_str(&cfg_str);
	code.push_str(&format!("pub static {}: &[u8] = &[];\n\n", const_name));
}
