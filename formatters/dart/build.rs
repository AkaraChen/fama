use std::env;
use std::fs;
use std::path::PathBuf;

fn main() {
	let manifest_dir = PathBuf::from(env::var("CARGO_MANIFEST_DIR").unwrap());
	let out_dir = PathBuf::from(env::var("OUT_DIR").unwrap());
	let bin_dir = manifest_dir.join("bin");

	println!("cargo:rerun-if-changed={}", bin_dir.display());

	// Platform configurations matching GitHub Actions artifact names
	let platforms = vec![
		// Linux
		("x86_64", "linux", "dart_style-linux-x86_64"),
		("aarch64", "linux", "dart_style-linux-aarch64"),
		// macOS
		("x86_64", "macos", "dart_style-macos-x86_64"),
		("aarch64", "macos", "dart_style-macos-aarch64"),
		// Windows MSVC
		("x86_64", "windows", "dart_style-windows-x86_64-msvc.exe"),
		("x86", "windows", "dart_style-windows-i686-msvc.exe"),
		("aarch64", "windows", "dart_style-windows-aarch64-msvc.exe"),
		// Windows GNU
		("x86_64", "windows", "dart_style-windows-x86_64-gnu.exe"),
	];

	// Generate the binary data file
	let binary_data_rs = out_dir.join("binary_data.rs");
	let mut generated_code = String::new();

	generated_code.push_str("// Auto-generated by build.rs\n");
	generated_code.push_str(
		"// This file contains the embedded binary data for dart_style\n\n",
	);

	for (arch, os, binary_name) in &platforms {
		let binary_path = bin_dir.join(binary_name);

		if binary_path.exists() {
			let size = fs::metadata(&binary_path).map(|m| m.len()).unwrap_or(0);
			if size > 0 {
				println!(
					"cargo:warning=Including binary for {}-{}: {} ({} bytes)",
					arch, os, binary_name, size
				);

				// Generate const name
				let const_name = format!(
					"BINARY_{}_{}",
					arch.to_uppercase().replace("-", "_"),
					os.to_uppercase()
				);

				// Write the byte array using include_bytes!
				generated_code.push_str(&format!(
					"#[cfg(all(target_arch = \"{}\", target_os = \"{}\"))]\n",
					arch, os
				));
				generated_code.push_str(&format!(
					"pub static {}: &[u8] = include_bytes!(\"{}\");\n\n",
					const_name,
					binary_path.display()
				));
			} else {
				println!(
					"cargo:warning=Binary file is empty for {}-{}: {}",
					arch,
					os,
					binary_path.display()
				);
				generate_placeholder(
					&mut generated_code,
					arch,
					os,
					&format!(
						"BINARY_{}_{}",
						arch.to_uppercase().replace("-", "_"),
						os.to_uppercase()
					),
				);
			}
		} else {
			println!(
				"cargo:warning=Binary not found for {}-{}: {}",
				arch,
				os,
				binary_path.display()
			);
			generate_placeholder(
				&mut generated_code,
				arch,
				os,
				&format!(
					"BINARY_{}_{}",
					arch.to_uppercase().replace("-", "_"),
					os.to_uppercase()
				),
			);
		}
	}

	fs::write(&binary_data_rs, generated_code)
		.expect("Failed to write binary_data.rs");

	println!(
		"cargo:warning=Generated binary data at {}",
		binary_data_rs.display()
	);
}

fn generate_placeholder(
	code: &mut String,
	arch: &str,
	os: &str,
	const_name: &str,
) {
	code.push_str(&format!(
		"#[cfg(all(target_arch = \"{}\", target_os = \"{}\"))]\n",
		arch, os
	));
	code.push_str(&format!("pub static {}: &[u8] = &[];\n\n", const_name));
}
